<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>inteligencia artificial</title>
</head>
<body>
    <h1>clase inteligencia artificial</h1>
    <p> en esta clase aprendimos github</p>
    <br>
    <h2> Temas sugeridos</h2>
    <img src="imagenes/imagen.jpg" width="300" height="300">

    <BR>
    </head>
    <body>
        <h1>clase inteligencia artificial</h1>
        <p> en esta clase aprendimos github</p>
        <br>
        <h2> Temas sugeridos</h2>
        <img src="imagenes/git.jpg" width="300" height="300">
    
        <BR>
            <h2> ACTIVIDAD 22/08/2024</H2>
               <img src="imagenes/ia.jpg" width="300px" height="300px">
            
               <p>  aprendi que exixten diferentes tipos de algoritmos  </p>
               <p>  aprendi que tenemos un break de 15 minutos </p>
            
            <br>



            <BR>
                <h3> ACTIVIDAD 29/08/2024</H2>
                   <img src="imagenes/red.png" width="300px" height="300px">
                
                   <p>  El video da una charla de Andrew Ng sobre las redes neuronales y el aprendizaje profundo (deep learning). Ng explica los conceptos básicos de las redes neuronales, cómo se entrenan y cómo han evolucionado para convertirse en una parte esencial del campo de la inteligencia artificial. Utiliza ejemplos visuales para mostrar cómo las redes neuronales pueden aprender a reconocer patrones en los datos y cómo se ajustan los parámetros para mejorar la precisión de los modelos. Es una introducción accesible para quienes quieren entender los fundamentos del deep learning.  </p>
                   
                   <BR>
                    <h3> parcial 26/09/2024</H2>
                       <img src="imagenes/Captura.PNG" width="300px" height="300px">
                    
                       <p> la imagen corresponde al punto 3 del parcial   </p>
                       
                    

                       <BR>
                        <h3> parcial 26/09/2024</H2>
                           <img src="imagenes/punto4.PNG" width="600" height="600">
                        
                           <p> la imagen corresponde al punto 4 del parcial   </p>
                           
                    <br>
                
                <br>


                <h2>   RESULTADOS INTERESES 10/10/2024</h2>
<P> Resultado encuesta</P>
<img src="imagenes/resultado puntaje.PNG" width="600" height="600">
<br>
<img src="imagenes/resultado.PNG" width="600" height="600">
<br>
<img src="imagenes/resul.PNG" width="600" height="600">
<br>
<p> SEGUNDA ENCUESTA</p>
<img src="imagenes/segundaprueba.PNG" width="600" height="600">
    </body>
</html>




</body>
</html>


<h2>   segundo parcial 24/10/2024</h2>
<P> punto 5</P>
<pre> <code>
    import itertools


    class Sentence():
        """
        Clase base para representar una oración lógica.
        """
    
        def evaluate(self, model):
            """Evalúa la oración lógica en un modelo dado."""
            raise Exception("nothing to evaluate")
    
        def formula(self):
            """Devuelve una cadena que representa la fórmula de la oración lógica."""
            return ""
    
        def symbols(self):
            """Devuelve un conjunto de todos los símbolos en la oración lógica."""
            return set()
    
        @classmethod
        def validate(cls, sentence):
            """Valida que el argumento sea una instancia de Sentence."""
            if not isinstance(sentence, Sentence):
                raise TypeError("must be a logical sentence")
    
        @classmethod
        def parenthesize(cls, s):
            """
            Añade paréntesis a una expresión si no está ya correctamente parentizada.
            """
            def balanced(s):
                """Verifica si una cadena tiene paréntesis balanceados."""
                count = 0
                for c in s:
                    if c == "(":
                        count += 1
                    elif c == ")":
                        if count <= 0:
                            return False
                        count -= 1
                return count == 0
    
            # Si la expresión ya está correctamente parentizada, no hace nada
            if not len(s) or s.isalpha() or (
                s[0] == "(" and s[-1] == ")" and balanced(s[1:-1])
            ):
                return s
            else:
                return f"({s})"
    
    
    class Symbol(Sentence):
        """
        Clase que representa un símbolo lógico.
        """
    
        def __init__(self, name):
            self.name = name
    
        def __eq__(self, other):
            return isinstance(other, Symbol) and self.name == other.name
    
        def __hash__(self):
            return hash(("symbol", self.name))
    
        def __repr__(self):
            return self.name
    
        def evaluate(self, model):
            """Evalúa el símbolo en el modelo dado."""
            try:
                return bool(model[self.name])
            except KeyError:
                raise EvaluationException(f"variable {self.name} not in model")
    
        def formula(self):
            return self.name
    
        def symbols(self):
            """Devuelve un conjunto que contiene el símbolo mismo."""
            return {self.name}
    
    
    class Not(Sentence):
        """
        Clase que representa una negación lógica.
        """
    
        def __init__(self, operand):
            Sentence.validate(operand)  # Verifica que el operando sea una oración lógica
            self.operand = operand
    
        def __eq__(self, other):
            return isinstance(other, Not) and self.operand == other.operand
    
        def __hash__(self):
            return hash(("not", hash(self.operand)))
    
        def __repr__(self):
            return f"Not({self.operand})"
    
        def evaluate(self, model):
            """Evalúa la negación del operando en el modelo dado."""
            return not self.operand.evaluate(model)
    
        def formula(self):
            """Devuelve la representación de la negación en formato fórmula lógica."""
            return "¬" + Sentence.parenthesize(self.operand.formula())
    
        def symbols(self):
            """Devuelve los símbolos utilizados en el operando."""
            return self.operand.symbols()
    
    
    class And(Sentence):
        """
        Clase que representa una conjunción lógica (Y lógico).
        """
    
        def __init__(self, *conjuncts):
            for conjunct in conjuncts:
                Sentence.validate(conjunct)  # Valida que cada término sea una oración lógica
            self.conjuncts = list(conjuncts)
    
        def __eq__(self, other):
            return isinstance(other, And) and self.conjuncts == other.conjuncts
    
        def __hash__(self):
            return hash(
                ("and", tuple(hash(conjunct) for conjunct in self.conjuncts))
            )
    
        def __repr__(self):
            conjunctions = ", ".join(
                [str(conjunct) for conjunct in self.conjuncts]
            )
            return f"And({conjunctions})"
    
        def add(self, conjunct):
            """Añade un nuevo término a la conjunción."""
            Sentence.validate(conjunct)
            self.conjuncts.append(conjunct)
    
        def evaluate(self, model):
            """Evalúa la conjunción (Y lógico) en el modelo dado."""
            return all(conjunct.evaluate(model) for conjunct in self.conjuncts)
    
        def formula(self):
            """Devuelve la representación de la conjunción en formato fórmula lógica."""
            if len(self.conjuncts) == 1:
                return self.conjuncts[0].formula()
            return " ∧ ".join([Sentence.parenthesize(conjunct.formula())
                               for conjunct in self.conjuncts])
    
        def symbols(self):
            """Devuelve los símbolos utilizados en todos los términos."""
            return set.union(*[conjunct.symbols() for conjunct in self.conjuncts])
    
    
    class Or(Sentence):
        """
        Clase que representa una disyunción lógica (O lógico).
        """
    
        def __init__(self, *disjuncts):
            for disjunct in disjuncts:
                Sentence.validate(disjunct)  # Valida que cada término sea una oración lógica
            self.disjuncts = list(disjuncts)
    
        def __eq__(self, other):
            return isinstance(other, Or) and self.disjuncts == other.disjuncts
    
        def __hash__(self):
            return hash(
                ("or", tuple(hash(disjunct) for disjunct in self.disjuncts))
            )
    
        def __repr__(self):
            disjuncts = ", ".join([str(disjunct) for disjunct in self.disjuncts])
            return f"Or({disjuncts})"
    
        def evaluate(self, model):
            """Evalúa la disyunción (O lógico) en el modelo dado."""
            return any(disjunct.evaluate(model) for disjunct in self.disjuncts)
    
        def formula(self):
            """Devuelve la representación de la disyunción en formato fórmula lógica."""
            if len(self.disjuncts == 1):
                return self.disjuncts[0].formula()
            return " ∨  ".join([Sentence.parenthesize(disjunct.formula())
                                for disjunct in self.disjuncts])
    
        def symbols(self):
            """Devuelve los símbolos utilizados en todos los términos."""
            return set.union(*[disjunct.symbols() for disjunct in self.disjuncts])
    
    
    class Implication(Sentence):
        """
        Clase que representa una implicación lógica (si A, entonces B).
        """
    
        def __init__(self, antecedent, consequent):
            Sentence.validate(antecedent)  # Valida que el antecedente sea una oración lógica
            Sentence.validate(consequent)  # Valida que el consecuente sea una oración lógica
            self.antecedent = antecedent
            self.consequent = consequent
    
        def __eq__(self, other):
            return (isinstance(other, Implication)
                    and self.antecedent == other.antecedent
                    and self.consequent == other.consequent)
    
        def __hash__(self):
            return hash(("implies", hash(self.antecedent), hash(self.consequent)))
    
        def __repr__(self):
            return f"Implication({self.antecedent}, {self.consequent})"
    
        def evaluate(self, model):
            """Evalúa la implicación en el modelo dado."""
            return ((not self.antecedent.evaluate(model))
                    or self.consequent.evaluate(model))
    
        def formula(self):
            """Devuelve la representación de la implicación en formato fórmula lógica."""
            antecedent = Sentence.parenthesize(self.antecedent.formula())
            consequent = Sentence.parenthesize(self.consequent.formula())
            return f"{antecedent} => {consequent}"
    
        def symbols(self):
            """Devuelve los símbolos utilizados en el antecedente y consecuente."""
            return set.union(self.antecedent.symbols(), self.consequent.symbols())
    
    
    class Biconditional(Sentence):
        """
        Clase que representa una bicondicional lógica (A si y solo si B).
        """
    
        def __init__(self, left, right):
            Sentence.validate(left)  # Valida que el término izquierdo sea una oración lógica
            Sentence.validate(right)  # Valida que el término derecho sea una oración lógica
            self.left = left
            self.right = right
    
        def __eq__(self, other):
            return (isinstance(other, Biconditional)
                    and self.left == other.left
                    and self.right == other.right)
    
        def __hash__(self):
            return hash(("biconditional", hash(self.left), hash(self.right)))
    
        def __repr__(self):
            return f"Biconditional({self.left}, {self.right})"
    
        def evaluate(self, model):
            """Evalúa la bicondicional en el modelo dado."""
            return ((self.left.evaluate(model)
                     and self.right.evaluate(model))
                    or (not self.left.evaluate(model)
                        and not self.right.evaluate(model)))
    
        def formula(self):
            """Devuelve la representación de la bicondicional en formato fórmula lógica."""
            left = Sentence.parenthesize(str(self.left))
            right = Sentence.parenthesize(str(self.right))
            return f"{left} <=> {right}"
    
        def symbols(self):
            """Devuelve los símbolos utilizados en ambos términos."""
            return set.union(self.left.symbols(), self.right.symbols())
    
    
    def model_check(knowledge, query):
        """
        Verifica si la base de conocimiento (knowledge) implica la consulta (query).
        """
    
        def check_all(knowledge, query, symbols, model):
            """Verifica si la base de conocimiento implica la consulta en un modelo específico."""
    
            # Si el modelo tiene una asignación para cada símbolo
            if not symbols:
    
                # Si la base de conocimiento es verdadera en el modelo, la consulta también debe ser verdadera
                if knowledge.evaluate(model):
                    return query.evaluate(model)
                return True
            else:
    
                # Escoge uno de los símbolos restantes
                remaining = symbols.copy()
                p = remaining.pop()
    
                # Crea un modelo donde el símbolo es verdadero
                model_true = model.copy()
                model_true[p] = True
    
                # Crea un modelo donde el símbolo es falso
                model_false = model.copy()
                model_false[p] = False
    
                # Asegura que la implicación sea válida en ambos modelos
                return (check_all(knowledge, query, remaining, model_true) and
                        check_all(knowledge, query, remaining, model_false))
    
        # Obtiene todos los símbolos en la base de conocimiento y la consulta
        symbols = set.union(knowledge.symbols(), query.symbols())
    
        # Verifica si la base de conocimiento implica la consulta
        return check_all(knowledge, query, symbols, dict())
    


</code> </pre>

    </body>
</html>

<h2>   segundo parcial 24/10/2024</h2>
<P> punto 6</P>
<pre> <code>
    from logic import *

# Definición de los símbolos
rain = Symbol("rain")
bbc = Symbol("bbc")
unimayor = Symbol("unimayor")

# Conjunto de conocimiento
knowledge = And(
    Implication(Not(rain), bbc),            # Si no llueve, los estudiantes visitan BBC
    Or(bbc, unimayor),                      # Estudiantes visitan BBC o Unimayor
    Not(And(bbc, unimayor)),                # No visitan ambos lugares a la vez
    unimayor                                # Estudiantes visitaron Unimayor
)

# Inferencias
print("¿Qué podemos inferir acerca de BBC?:", model_check(knowledge, bbc))
print("¿Qué podemos inferir acerca del clima?:", model_check(knowledge, rain))
</code> </pre>



</body>
</html>